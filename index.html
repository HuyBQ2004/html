<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
 <HEAD>
  <TITLE> Heart </TITLE>
  <META NAME="Generator" CONTENT="EditPlus">
  <META NAME="Author" CONTENT="">
  <META NAME="Keywords" CONTENT="">
  <META NAME="Description" CONTENT="">
  <style>
  html, body {
    height: 100%;
    padding: 0;
    margin: 0;
    background: #000;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  .box {
    width: 100%;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    display: flex;
    flex-direction: column;
  }
  canvas {
    position: absolute;
    width: 100%;
    height: 100%;
  }
  #pinkboard {
    position: relative;
    margin: auto;
    height: 500px;
    width: 500px;
    animation: animate 1.3s infinite;
  }
  #pinkboard:before, #pinkboard:after {
    content: '';
    position: absolute;
    background: #FF5CA4;
    width: 100px;
    height: 160px;
    border-top-left-radius: 50px;
    border-top-right-radius: 50px;
  }
  #pinkboard:before {
    left: 100px;
    transform: rotate(-45deg);
    transform-origin: 0 100%;
    box-shadow: 0 14px 28px rgba(0,0,0,0.25),
                0 10px 10px rgba(0,0,0,0.22);
  }
  #pinkboard:after {
    left: 0;
    transform: rotate(45deg);
    transform-origin: 100% 100%;
  }
  @keyframes animate {
    0% { transform: scale(1); }
    30% { transform: scale(.8); }
    60% { transform: scale(1.2); }
    100% { transform: scale(1); }
  }
  </style>
 </HEAD>
 <BODY>
   <div class="box">
      <canvas id="pinkboard"></canvas>
   </div>
   <!-- Thêm thẻ audio cho nhạc nền -->
   <!-- <audio autoplay loop>
     <source src="music.mp3" type="audio/mpeg">
     Trình duyệt của bạn không hỗ trợ thẻ audio.
   </audio> -->
   <div class="center-text" style="background-color:rgb(0,0,0); width:100%; color:rgb(225, 12, 12); height:100%; font-size:31px; font-style:italic; display:flex; align-items:center; justify-content:center; margin-bottom:5px; text-align:center; font-size: 1.2rem;"></div>
  <script>
  var settings = {
    particles: {
      length: 2000,
      duration: 2,
      velocity: 100,
      effect: -1.3,
      size: 13,
    },
  };

  var upwardSettings = {
    particles: {
      length: 500,
      duration: 10,
      velocity: 50,
      effect: 0,
      size: 7,
    },
  };

  (function(){var b=0;var c=["ms","moz","webkit","o"];for(var a=0;a<c.length&&!window.requestAnimationFrame;++a){window.requestAnimationFrame=window[c[a]+"RequestAnimationFrame"];window.cancelAnimationFrame=window[c[a]+"CancelAnimationFrame"]||window[c[a]+"CancelRequestAnimationFrame"]}if(!window.requestAnimationFrame){window.requestAnimationFrame=function(h,e){var d=new Date().getTime();var f=Math.max(0,16-(d-b));var g=window.setTimeout(function(){h(d+f)},f);b=d+f;return g}}if(!window.cancelAnimationFrame){window.cancelAnimationFrame=function(d){clearTimeout(d)}}}());

  var Point = (function() {
    function Point(x, y) {
      this.x = (typeof x !== 'undefined') ? x : 0;
      this.y = (typeof y !== 'undefined') ? y : 0;
    }
    Point.prototype.clone = function() { return new Point(this.x, this.y); };
    Point.prototype.length = function(length) {
      if (typeof length == 'undefined') return Math.sqrt(this.x * this.x + this.y * this.y);
      this.normalize();
      this.x *= length;
      this.y *= length;
      return this;
    };
    Point.prototype.normalize = function() {
      var length = this.length();
      this.x /= length;
      this.y /= length;
      return this;
    };
    return Point;
  })();

  var Particle = (function() {
    function Particle() {
      this.position = new Point();
      this.velocity = new Point();
      this.acceleration = new Point();
      this.age = 0;
    }
    Particle.prototype.initialize = function(x, y, dx, dy, effect) {
      this.position.x = x;
      this.position.y = y;
      this.velocity.x = dx;
      this.velocity.y = dy;
      this.acceleration.x = dx * effect;
      this.acceleration.y = dy * effect;
      this.age = 0;
    };
    Particle.prototype.update = function(deltaTime) {
      this.position.x += this.velocity.x * deltaTime;
      this.position.y += this.velocity.y * deltaTime;
      this.velocity.x += this.acceleration.x * deltaTime;
      this.velocity.y += this.acceleration.y * deltaTime;
      this.age += deltaTime;
    };
    Particle.prototype.draw = function(context, image, duration) {
      function ease(t) { return (--t) * t * t + 1; }
      var size = image.width * ease(this.age / duration);
      context.globalAlpha = 1 - this.age / duration;
      context.drawImage(image, this.position.x - size / 2, this.position.y - size / 2, size, size);
    };
    return Particle;
  })();

  var ParticlePool = (function() {
    function ParticlePool(length, duration, effect) {
      this.particles = new Array(length);
      for (var i = 0; i < this.particles.length; i++)
        this.particles[i] = new Particle();
      this.duration = duration;
      this.effect = effect;
      this.firstActive = 0;
      this.firstFree = 0;
    }
    ParticlePool.prototype.add = function(x, y, dx, dy) {
      this.particles[this.firstFree].initialize(x, y, dx, dy, this.effect);
      this.firstFree++;
      if (this.firstFree == this.particles.length) this.firstFree = 0;
      if (this.firstActive == this.firstFree) this.firstActive++;
      if (this.firstActive == this.particles.length) this.firstActive = 0;
    };
    ParticlePool.prototype.update = function(deltaTime) {
      var i;
      if (this.firstActive < this.firstFree) {
        for (i = this.firstActive; i < this.firstFree; i++)
          this.particles[i].update(deltaTime);
      }
      if (this.firstFree < this.firstActive) {
        for (i = this.firstActive; i < this.particles.length; i++)
          this.particles[i].update(deltaTime);
        for (i = 0; i < this.firstFree; i++)
          this.particles[i].update(deltaTime);
      }
      while (this.particles[this.firstActive].age >= this.duration && this.firstActive != this.firstFree) {
        this.firstActive++;
        if (this.firstActive == this.particles.length) this.firstActive = 0;
      }
    };
    ParticlePool.prototype.draw = function(context, image) {
      var i;
      if (this.firstActive < this.firstFree) {
        for (i = this.firstActive; i < this.firstFree; i++)
          this.particles[i].draw(context, image, this.duration);
      }
      if (this.firstFree < this.firstActive) {
        for (i = this.firstActive; i < this.particles.length; i++)
          this.particles[i].draw(context, image, this.duration);
        for (i = 0; i < this.firstFree; i++)
          this.particles[i].draw(context, image, this.duration);
      }
    };
    return ParticlePool;
  })();

  // Tạo đối tượng ảnh
  var customImage = new Image();
  //customImage.src = 'pictrue.jpg'; // Thay bằng đường dẫn ảnh thực tế

  (function(canvas) {
    var context = canvas.getContext('2d'),
        particles = new ParticlePool(settings.particles.length, settings.particles.duration, settings.particles.effect),
        upwardParticles = new ParticlePool(upwardSettings.particles.length, upwardSettings.particles.duration, upwardSettings.particles.effect),
        particleRate = settings.particles.length / settings.particles.duration,
        upwardParticleRate = upwardSettings.particles.length / upwardSettings.particles.duration,
        time;

    function pointOnHeart(t) {
      return new Point(
        160 * Math.pow(Math.sin(t), 3),
        130 * Math.cos(t) - 50 * Math.cos(2 * t) - 20 * Math.cos(3 * t) - 10 * Math.cos(4 * t) + 25
      );
    }

    var image = (function() {
      var canvas = document.createElement('canvas'),
          context = canvas.getContext('2d');
      canvas.width = settings.particles.size;
      canvas.height = settings.particles.size;
      function to(t) {
        var point = pointOnHeart(t);
        point.x = settings.particles.size / 2 + point.x * settings.particles.size / 350;
        point.y = settings.particles.size / 2 - point.y * settings.particles.size / 350;
        return point;
      }
      context.beginPath();
      var t = -Math.PI;
      var point = to(t);
      context.moveTo(point.x, point.y);
      while (t < Math.PI) {
        t += 0.01;
        point = to(t);
        context.lineTo(point.x, point.y);
      }
      context.closePath();
      context.fillStyle = '#FF5CA4';
      context.fill();
      var image = new Image();
      image.src = canvas.toDataURL();
      return image;
    })();

    var smallHeartImage = (function() {
      var canvas = document.createElement('canvas'),
          context = canvas.getContext('2d');
      canvas.width = upwardSettings.particles.size;
      canvas.height = upwardSettings.particles.size;
      function to(t) {
        var point = pointOnHeart(t);
        point.x = upwardSettings.particles.size / 2 + point.x * upwardSettings.particles.size / 350;
        point.y = upwardSettings.particles.size / 2 - point.y * upwardSettings.particles.size / 350;
        return point;
      }
      context.beginPath();
      var t = -Math.PI;
      var point = to(t);
      context.moveTo(point.x, point.y);
      while (t < Math.PI) {
        t += 0.01;
        point = to(t);
        context.lineTo(point.x, point.y);
      }
      context.closePath();
      context.fillStyle = '#FF5CA4';
      context.fill();
      var image = new Image();
      image.src = canvas.toDataURL();
      return image;
    })();

    function render() {
      requestAnimationFrame(render);
      var newTime = new Date().getTime() / 1000,
          deltaTime = newTime - (time || newTime);
      time = newTime;

      context.clearRect(0, 0, canvas.width, canvas.height);

      // Vẽ ảnh bên trong trái tim nếu ảnh đã tải xong
      if (customImage.complete) {
    context.save();
    context.beginPath();
    var t = -Math.PI;
    var point = pointOnHeart(t);
    var x = canvas.width / 2 + point.x;
    var y = canvas.height / 2 - point.y;
    context.moveTo(x, y);
    while (t < Math.PI) {
        t += 0.01;
        point = pointOnHeart(t);
        x = canvas.width / 2 + point.x;
        y = canvas.height / 2 - point.y;
        context.lineTo(x, y);
    }
    context.closePath();
    context.clip();

    // Tính toán kích thước và vị trí để ảnh vừa khít với trái tim
    var heartWidth = 320;  // Chiều rộng ước lượng của trái tim
    var heartHeight = 320; // Chiều cao ước lượng của trái tim
    var scale = Math.min(heartWidth / customImage.width, heartHeight / customImage.height);
    var imgWidth = customImage.width * scale;
    var imgHeight = customImage.height * scale;
    
    // Thêm offset để dịch chuyển ảnh lên trên nếu cần
    var offset = 20; // Giá trị này có thể điều chỉnh
    var imgX = canvas.width / 2 - imgWidth / 2;
    var imgY = canvas.height / 2 - imgHeight / 2 - offset;

    context.drawImage(customImage, imgX, imgY, imgWidth, imgHeight);
    context.restore();
}

      var amount = particleRate * deltaTime;
      for (var i = 0; i < amount; i++) {
        var pos = pointOnHeart(Math.PI - 2 * Math.PI * Math.random());
        var dir = pos.clone().length(settings.particles.velocity);
        particles.add(canvas.width / 2 + pos.x, canvas.height / 2 - pos.y, dir.x, -dir.y);
      }

      var upwardAmount = upwardParticleRate * deltaTime;
      for (var i = 0; i < upwardAmount; i++) {
        var edge = Math.floor(Math.random() * 3);
        var x, y, dx, dy;
        if (edge === 0) {
          x = Math.random() * canvas.width;
          y = canvas.height;
          dx = (Math.random() - 0.5) * 20;
          dy = -upwardSettings.particles.velocity;
        } else if (edge === 1) {
          x = 0;
          y = Math.random() * canvas.height;
          dx = upwardSettings.particles.velocity;
          dy = (Math.random() - 0.5) * 20;
        } else {
          x = canvas.width;
          y = Math.random() * canvas.height;
          dx = -upwardSettings.particles.velocity;
          dy = (Math.random() - 0.5) * 20;
        }
        upwardParticles.add(x, y, dx, dy);
      }

      particles.update(deltaTime);
      upwardParticles.update(deltaTime);
      particles.draw(context, image);
      upwardParticles.draw(context, smallHeartImage);
    }

    function onResize() {
      canvas.width = canvas.clientWidth;
      canvas.height = canvas.clientHeight;
    }
    window.onresize = onResize;

    setTimeout(function() {
      onResize();
      render();
    }, 10);
  })(document.getElementById('pinkboard'));
  </script>
 </BODY>
</HTML>